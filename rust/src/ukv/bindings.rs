/* automatically generated by rust-bindgen 0.63.0 */

pub const __GNUC_VA_LIST: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
	pub __mbstate8: [::std::os::raw::c_char; 128usize],
	pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
	const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<__mbstate_t>(),
		128usize,
		concat!("Size of: ", stringify!(__mbstate_t))
	);
	assert_eq!(
		::std::mem::align_of::<__mbstate_t>(),
		8usize,
		concat!("Alignment of ", stringify!(__mbstate_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(__mbstate_t), "::", stringify!(__mbstate8))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(__mbstate_t), "::", stringify!(_mbstateL))
	);
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
	pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
	pub __arg: *mut ::std::os::raw::c_void,
	pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
	const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<__darwin_pthread_handler_rec>(),
		24usize,
		concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
	);
	assert_eq!(
		::std::mem::align_of::<__darwin_pthread_handler_rec>(),
		8usize,
		concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__darwin_pthread_handler_rec),
			"::",
			stringify!(__routine)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(__darwin_pthread_handler_rec),
			"::",
			stringify!(__arg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(__darwin_pthread_handler_rec),
			"::",
			stringify!(__next)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_attr_t>(),
		64usize,
		concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_attr_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(_opaque_pthread_attr_t), "::", stringify!(__sig))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_attr_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_cond_t>(),
		48usize,
		concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_cond_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(_opaque_pthread_cond_t), "::", stringify!(__sig))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_cond_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_condattr_t>(),
		16usize,
		concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_condattr_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_condattr_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_condattr_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_mutex_t>(),
		64usize,
		concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_mutex_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(_opaque_pthread_mutex_t), "::", stringify!(__sig))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_mutex_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
		16usize,
		concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_mutexattr_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_mutexattr_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_once_t>(),
		16usize,
		concat!("Size of: ", stringify!(_opaque_pthread_once_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_once_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(_opaque_pthread_once_t), "::", stringify!(__sig))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_once_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
		200usize,
		concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(_opaque_pthread_rwlock_t), "::", stringify!(__sig))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_rwlock_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
		24usize,
		concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_rwlockattr_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_rwlockattr_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
	pub __sig: ::std::os::raw::c_long,
	pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
	pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_t>(),
		8192usize,
		concat!("Size of: ", stringify!(_opaque_pthread_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(_opaque_pthread_t), "::", stringify!(__sig))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_t),
			"::",
			stringify!(__cleanup_stack)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		16usize,
		concat!("Offset of field: ", stringify!(_opaque_pthread_t), "::", stringify!(__opaque))
	);
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[doc = " @brief Opaque multi-modal Database handle.\n @see `ukv_database_free()`.\n\n Properties:\n - Thread safety: Safe to use across threads after open and before free.\n - Lifetime: Must live longer than all the transactions.\n\n ## Concurrency\n\n In embedded setup this handle manages the lifetime of the database.\n In that case user must guarantee, that concurrent processes won't be\n opening the same database (generally same directory).\n\n In standalone \"client-server\" setup, manages the lifetime of the \"client\".\n Many concurrent clients can be connecting to the same server from the same\n process.\n\n ## Collections\n\n Every database always has at least one collection - the `::ukv_collection_main_k`.\n That one has no name and can't be deleted. Others are referenced by names.\n The same database can have many collections, of different modalities:\n - Binary Large Objects or BLOBs.\n - Hierarchical documents, like JSONs, BSONs, MessagePacks.\n - Discrete labeled and potentially directed Graphs.\n - Paths or collections of string keys.\n\n ## Choosing the Engine\n\n Dynamic dispatch of engines isn't yet supported.\n\n ## CAP Theorem\n\n Distributed engines are not yet supported."]
pub type ukv_database_t = *mut ::std::os::raw::c_void;
#[doc = " @brief Opaque Transaction handle.\n @see `ukv_transaction_free()`.\n @see https://unum.cloud/ukv/c#transactions\n\n Allows ACID-ly grouping operations across different collections and even modalities.\n This means, that the same transaction might be:\n - inserting a blob of media data into a collection of images.\n - updating users metadata in a documents collection to reference new avatar.\n - introducing links between the user and other in a graph collection...\n and all of the operations here either succeed or fail together. DBMS will\n do the synchronization heavy-lifting, so you don't have to.\n\n Properties:\n - Thread safety: None.\n - Lifetime: Must be freed before the @c ukv_database_t is closed.\n - Concurrency Control: Optimistic."]
pub type ukv_transaction_t = *mut ::std::os::raw::c_void;
#[doc = " @brief Some unique integer identifier of a collection.\n A @c ukv_database_t database can have many of those,\n but never with repeating names or identifiers.\n Those identifiers are not guaranteed to remain the same\n between DBMS restarts."]
pub type ukv_collection_t = u64;
#[doc = " @brief The unique identifier of any value within a single collection."]
pub type ukv_key_t = i64;
#[doc = " @brief The elementary binary piece of any value."]
pub type ukv_byte_t = u8;
#[doc = " @brief Single-precisions floating-point number."]
pub type ukv_float_t = f32;
#[doc = " @brief The elementary piece of any string, like collection name."]
pub type ukv_char_t = ::std::os::raw::c_char;
#[doc = " @brief The length of any value in the DB."]
pub type ukv_length_t = u32;
#[doc = " @brief Pointer-sized integer type."]
pub type ukv_size_t = u64;
#[doc = " @brief The smallest possible \"bitset\" type, storing eight zeros or ones."]
pub type ukv_octet_t = u8;
#[doc = " @brief Monotonically increasing unique identifier that reflects the order of applied transactions"]
pub type ukv_sequence_number_t = u64;
#[doc = " @brief Owning error message string.\n If not null, must be deallocated via `ukv_error_free()`."]
pub type ukv_error_t = *const ::std::os::raw::c_char;
#[doc = " @brief Non-owning string reference.\n Always provided by user and we don't participate\n in its lifetime management in any way."]
pub type ukv_str_view_t = *const ::std::os::raw::c_char;
pub type ukv_str_span_t = *mut ::std::os::raw::c_char;
#[doc = " @brief Temporary memory handle, used mostly for read requests.\n It's allocated, resized and deallocated only by UKV itself.\n Once done, must be deallocated with `ukv_arena_free()`.\n @see `ukv_arena_free()`."]
pub type ukv_arena_t = *mut ::std::os::raw::c_void;
pub type ukv_bytes_ptr_t = *mut u8;
pub type ukv_bytes_cptr_t = *const u8;
pub type ukv_callback_payload_t = *mut ::std::os::raw::c_void;
pub type ukv_callback_t = ::std::option::Option<unsafe extern "C" fn(arg1: ukv_callback_payload_t)>;
pub const ukv_options_t_ukv_options_default_k: ukv_options_t = 0;
#[doc = " @brief Forces absolute consistency on the write operations\n flushing all the data to disk after each write. It's usage\n may cause severe performance degradation in some implementations.\n Yet the users must be warned, that modern IO drivers still often\n can't guarantee that everything will reach the disk."]
pub const ukv_options_t_ukv_option_write_flush_k: ukv_options_t = 2;
#[doc = " @brief When reading from a transaction, we track the requested keys.\n If the requested key was updated since the read, the transaction\n will fail on commit or prior to that. This option disables collision\n detection on separate parts of transactional reads and writes."]
pub const ukv_options_t_ukv_option_transaction_dont_watch_k: ukv_options_t = 4;
#[doc = " @brief On every API call, the arena is cleared for reuse.\n If the arguments of the function are results of another UKV call,\n you can use this flag to avoid discarding the memory."]
pub const ukv_options_t_ukv_option_dont_discard_memory_k: ukv_options_t = 16;
#[doc = " @brief Will output data into shared memory, not the one privately\n to do further transformations without any copies.\n Is relevant for standalone distributions used with drivers supporting\n Apache Arrow buffers or standardized Tensor representations."]
pub const ukv_options_t_ukv_option_read_shared_memory_k: ukv_options_t = 32;
#[doc = " @brief When set, the underlying engine may avoid strict keys ordering\n and may include irrelevant (deleted & duplicate) keys in order to maximize\n throughput. The purpose is not accelerating the `ukv_scan()`, but the\n following `ukv_read()`. Generally used for Machine Learning applications."]
pub const ukv_options_t_ukv_option_scan_bulk_k: ukv_options_t = 0;
pub type ukv_options_t = ::std::os::raw::c_uint;
#[doc = " @brief Remove the handle and all of the contents."]
pub const ukv_drop_mode_t_ukv_drop_keys_vals_handle_k: ukv_drop_mode_t = 0;
#[doc = " @brief Remove keys and values, but keep the collection."]
pub const ukv_drop_mode_t_ukv_drop_keys_vals_k: ukv_drop_mode_t = 1;
#[doc = " @brief Clear the values, but keep the keys."]
pub const ukv_drop_mode_t_ukv_drop_vals_k: ukv_drop_mode_t = 2;
#[doc = " @brief The \"mode\" of collection removal."]
pub type ukv_drop_mode_t = ::std::os::raw::c_uint;
extern "C" {
	#[doc = " @brief The handle to the default nameless collection.\n It exists from start, doesn't have to be created and can't be fully dropped.\n Only `::ukv_drop_keys_vals_k` and `::ukv_drop_vals_k` apply to it."]
	pub static ukv_collection_main_k: ukv_collection_t;
}
extern "C" {
	pub static ukv_length_missing_k: ukv_length_t;
}
extern "C" {
	pub static ukv_key_unknown_k: ukv_key_t;
}
extern "C" {
	pub static ukv_supports_transactions_k: bool;
}
extern "C" {
	pub static ukv_supports_named_collections_k: bool;
}
extern "C" {
	pub static ukv_supports_snapshots_k: bool;
}
#[doc = " @brief Opens the underlying Key-Value Store.\n @see `ukv_database_init()`.\n\n Depending on the selected distribution can be any of:\n\n - embedded persistent transactional KVS\n - embedded in-memory transactional KVS\n - remote persistent transactional KVS\n - remote in-memory transactional KVS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ukv_database_init_t {
	#[doc = " @brief Configuration parameter for the DBMS.\n\n For embedded distributions should be the root directory,\n under which the DBMS and it's files will be organized.\n\n Recommendations:\n - UMem: empty or `/var/lib/ukv/umem/` for eventually persistent.\n - RocksDB: `/var/lib/ukv/rocksdb/` optionally storing `config_rocksdb.ini`.\n - LevelDB: `/var/lib/ukv/leveldb/` optionally storing `config_leveldb.json`.\n - Flight API Client: `grpc://0.0.0.0:38709`."]
	pub config: ukv_str_view_t,
	#[doc = " @brief A pointer to the opened KVS, unless `error` is filled."]
	pub db: *mut ukv_database_t,
	#[doc = " @brief Pointer to exported error message."]
	pub error: *mut ukv_error_t,
}
#[test]
fn bindgen_test_layout_ukv_database_init_t() {
	const UNINIT: ::std::mem::MaybeUninit<ukv_database_init_t> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ukv_database_init_t>(),
		24usize,
		concat!("Size of: ", stringify!(ukv_database_init_t))
	);
	assert_eq!(
		::std::mem::align_of::<ukv_database_init_t>(),
		8usize,
		concat!("Alignment of ", stringify!(ukv_database_init_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(ukv_database_init_t), "::", stringify!(config))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(ukv_database_init_t), "::", stringify!(db))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
		16usize,
		concat!("Offset of field: ", stringify!(ukv_database_init_t), "::", stringify!(error))
	);
}
extern "C" {
	#[doc = " @brief Opens the underlying Key-Value Store.\n @see `ukv_database_init()`."]
	pub fn ukv_database_init(arg1: *mut ukv_database_init_t);
}
#[doc = " @brief Lists all named collections in the DB.\n @see `ukv_collection_list()`.\n\n Retrieves a list of collection IDs & names in a NULL-delimited form.\n The default nameless collection won't be described in any form, as its always\n present. This is the only collection-management operation that can be performed\n on a DB state snapshot, and not just on the HEAD state."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ukv_collection_list_t {
	#[doc = " @brief Already open database instance."]
	pub db: ukv_database_t,
	#[doc = " @brief Pointer to exported error message.\n If not NULL, must be deallocated with `ukv_error_free()`."]
	pub error: *mut ukv_error_t,
	#[doc = " @brief The snapshot in which the retrieval will be conducted.\n @see `ukv_transaction_init()`, `ukv_transaction_commit()`, `ukv_transaction_free()`."]
	pub transaction: ukv_transaction_t,
	#[doc = " @brief Reusable memory handle.\n @see `ukv_arena_free()`."]
	pub arena: *mut ukv_arena_t,
	#[doc = " @brief Listing options.\n\n Possible values:\n - `::ukv_option_dont_discard_memory_k`: Won't reset the `arena` before the operation begins."]
	pub options: ukv_options_t,
	#[doc = " @brief Number of present collections."]
	pub count: *mut ukv_size_t,
	#[doc = " @brief Handles of all the collections in same order as `names`."]
	pub ids: *mut *mut ukv_collection_t,
	#[doc = " @brief Offsets of separate strings in the `names` tape."]
	pub offsets: *mut *mut ukv_length_t,
	#[doc = " @brief NULL-terminated collection names tape in same order as `ids`."]
	pub names: *mut *mut ukv_char_t,
}
#[test]
fn bindgen_test_layout_ukv_collection_list_t() {
	const UNINIT: ::std::mem::MaybeUninit<ukv_collection_list_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ukv_collection_list_t>(),
		72usize,
		concat!("Size of: ", stringify!(ukv_collection_list_t))
	);
	assert_eq!(
		::std::mem::align_of::<ukv_collection_list_t>(),
		8usize,
		concat!("Alignment of ", stringify!(ukv_collection_list_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(ukv_collection_list_t), "::", stringify!(db))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(ukv_collection_list_t), "::", stringify!(error))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).transaction) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(ukv_collection_list_t),
			"::",
			stringify!(transaction)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize },
		24usize,
		concat!("Offset of field: ", stringify!(ukv_collection_list_t), "::", stringify!(arena))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
		32usize,
		concat!("Offset of field: ", stringify!(ukv_collection_list_t), "::", stringify!(options))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
		40usize,
		concat!("Offset of field: ", stringify!(ukv_collection_list_t), "::", stringify!(count))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).ids) as usize - ptr as usize },
		48usize,
		concat!("Offset of field: ", stringify!(ukv_collection_list_t), "::", stringify!(ids))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).offsets) as usize - ptr as usize },
		56usize,
		concat!("Offset of field: ", stringify!(ukv_collection_list_t), "::", stringify!(offsets))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize },
		64usize,
		concat!("Offset of field: ", stringify!(ukv_collection_list_t), "::", stringify!(names))
	);
}
extern "C" {
	#[doc = " @brief Lists all named collections in the DB.\n @see `ukv_collection_list_t`."]
	pub fn ukv_collection_list(arg1: *mut ukv_collection_list_t);
}
#[doc = " @brief Creates a new uniquely named collection in the DB.\n @see `ukv_collection_create()`.\n\n This function may never be called, as the default nameless collection\n always exists and can be addressed via `::ukv_collection_main_k`.\n You can \"re-create\" an empty collection with a new config."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ukv_collection_create_t {
	#[doc = " @brief Already open database instance."]
	pub db: ukv_database_t,
	#[doc = " @brief Pointer to exported error message."]
	pub error: *mut ukv_error_t,
	#[doc = " @brief Unique name for the new collection."]
	pub name: ukv_str_view_t,
	#[doc = " @brief Optional configuration JSON string."]
	pub config: ukv_str_view_t,
	#[doc = " @brief Output for the collection handle."]
	pub id: *mut ukv_collection_t,
}
#[test]
fn bindgen_test_layout_ukv_collection_create_t() {
	const UNINIT: ::std::mem::MaybeUninit<ukv_collection_create_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ukv_collection_create_t>(),
		40usize,
		concat!("Size of: ", stringify!(ukv_collection_create_t))
	);
	assert_eq!(
		::std::mem::align_of::<ukv_collection_create_t>(),
		8usize,
		concat!("Alignment of ", stringify!(ukv_collection_create_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(ukv_collection_create_t), "::", stringify!(db))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(ukv_collection_create_t), "::", stringify!(error))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
		16usize,
		concat!("Offset of field: ", stringify!(ukv_collection_create_t), "::", stringify!(name))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
		24usize,
		concat!("Offset of field: ", stringify!(ukv_collection_create_t), "::", stringify!(config))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
		32usize,
		concat!("Offset of field: ", stringify!(ukv_collection_create_t), "::", stringify!(id))
	);
}
extern "C" {
	#[doc = " @brief Creates a new uniquely named collection in the DB.\n @see `ukv_collection_create_t`."]
	pub fn ukv_collection_create(arg1: *mut ukv_collection_create_t);
}
#[doc = " @brief Removes or clears an existing collection.\n @see `ukv_collection_drop()`.\n\n Removes a collection or its contents depending on `mode`.\n The default nameless collection can't be removed, only cleared."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ukv_collection_drop_t {
	#[doc = " @brief Already open database instance."]
	pub db: ukv_database_t,
	#[doc = " @brief Pointer to exported error message."]
	pub error: *mut ukv_error_t,
	#[doc = " @brief Existing collection handle."]
	pub id: ukv_collection_t,
	#[doc = " @brief Controls if values, pairs or the whole collection must be dropped."]
	pub mode: ukv_drop_mode_t,
}
#[test]
fn bindgen_test_layout_ukv_collection_drop_t() {
	const UNINIT: ::std::mem::MaybeUninit<ukv_collection_drop_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ukv_collection_drop_t>(),
		32usize,
		concat!("Size of: ", stringify!(ukv_collection_drop_t))
	);
	assert_eq!(
		::std::mem::align_of::<ukv_collection_drop_t>(),
		8usize,
		concat!("Alignment of ", stringify!(ukv_collection_drop_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(ukv_collection_drop_t), "::", stringify!(db))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(ukv_collection_drop_t), "::", stringify!(error))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
		16usize,
		concat!("Offset of field: ", stringify!(ukv_collection_drop_t), "::", stringify!(id))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
		24usize,
		concat!("Offset of field: ", stringify!(ukv_collection_drop_t), "::", stringify!(mode))
	);
}
extern "C" {
	#[doc = " @brief Removes or clears an existing collection.\n @see `ukv_collection_drop_t`."]
	pub fn ukv_collection_drop(arg1: *mut ukv_collection_drop_t);
}
#[doc = " @brief Free-form communication tunnel with the underlying engine.\n @see `ukv_database_control()`.\n\n Performs free-form queries on the DB, that may not necessarily\n have a stable API and a fixed format output. Generally, those requests\n are very expensive and shouldn't be executed in most applications.\n This is the \"kitchen-sink\" of UKV interface, similar to `fcntl` & `ioctl`.\n\n ## Possible Commands\n - \"clear\":   Removes all the data from DB, while keeping collection names.\n - \"reset\":   Removes all the data from DB, including collection names.\n - \"compact\": Flushes and compacts all the data in LSM-tree implementations.\n - \"info\":    Metadata about the current software version, used for debugging.\n - \"usage\":   Metadata about approximate collection sizes, RAM and disk usage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ukv_database_control_t {
	#[doc = " @brief Already open database instance."]
	pub db: ukv_database_t,
	#[doc = " @brief Reusable memory handle."]
	pub arena: *mut ukv_arena_t,
	#[doc = " @brief Pointer to exported error message."]
	pub error: *mut ukv_error_t,
	#[doc = " @brief The input command as a NULL-terminated string."]
	pub request: ukv_str_view_t,
	#[doc = " @brief The output response as a NULL-terminated string."]
	pub response: *mut ukv_str_view_t,
}
#[test]
fn bindgen_test_layout_ukv_database_control_t() {
	const UNINIT: ::std::mem::MaybeUninit<ukv_database_control_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ukv_database_control_t>(),
		40usize,
		concat!("Size of: ", stringify!(ukv_database_control_t))
	);
	assert_eq!(
		::std::mem::align_of::<ukv_database_control_t>(),
		8usize,
		concat!("Alignment of ", stringify!(ukv_database_control_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(ukv_database_control_t), "::", stringify!(db))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(ukv_database_control_t), "::", stringify!(arena))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
		16usize,
		concat!("Offset of field: ", stringify!(ukv_database_control_t), "::", stringify!(error))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
		24usize,
		concat!("Offset of field: ", stringify!(ukv_database_control_t), "::", stringify!(request))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).response) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(ukv_database_control_t),
			"::",
			stringify!(response)
		)
	);
}
extern "C" {
	#[doc = " @brief Free-form communication tunnel with the underlying engine.\n @see `ukv_database_control()`."]
	pub fn ukv_database_control(arg1: *mut ukv_database_control_t);
}
#[doc = " @brief Begins a new ACID transaction or resets an existing one.\n @see `ukv_transaction_init()`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ukv_transaction_init_t {
	#[doc = " @brief Already open database instance."]
	pub db: ukv_database_t,
	#[doc = " @brief Pointer to exported error message."]
	pub error: *mut ukv_error_t,
	#[doc = " @brief Transaction options.\n\n Possible values:\n - `::ukv_option_dont_discard_memory_k`: Won't reset the `arena` before the operation begins."]
	pub options: ukv_options_t,
	#[doc = " @brief In-out transaction handle."]
	pub transaction: *mut ukv_transaction_t,
}
#[test]
fn bindgen_test_layout_ukv_transaction_init_t() {
	const UNINIT: ::std::mem::MaybeUninit<ukv_transaction_init_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ukv_transaction_init_t>(),
		32usize,
		concat!("Size of: ", stringify!(ukv_transaction_init_t))
	);
	assert_eq!(
		::std::mem::align_of::<ukv_transaction_init_t>(),
		8usize,
		concat!("Alignment of ", stringify!(ukv_transaction_init_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(ukv_transaction_init_t), "::", stringify!(db))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(ukv_transaction_init_t), "::", stringify!(error))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
		16usize,
		concat!("Offset of field: ", stringify!(ukv_transaction_init_t), "::", stringify!(options))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).transaction) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(ukv_transaction_init_t),
			"::",
			stringify!(transaction)
		)
	);
}
extern "C" {
	#[doc = " @brief Begins a new ACID transaction or resets an existing one.\n @see `ukv_transaction_init_t`."]
	pub fn ukv_transaction_init(arg1: *mut ukv_transaction_init_t);
}
#[doc = " @brief Stages an ACID transaction for Two Phase Commits.\n @see `ukv_transaction_stage()`.\n\n Regardless of result, the content is preserved to allow further\n logging, serialization or retries. The underlying memory can be\n cleaned and reused by consecutive `ukv_transaction_init()` call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ukv_transaction_stage_t {
	#[doc = " @brief Already open database instance."]
	pub db: ukv_database_t,
	#[doc = " @brief Pointer to exported error message."]
	pub error: *mut ukv_error_t,
	#[doc = " @brief Initialized transaction handle."]
	pub transaction: ukv_transaction_t,
	#[doc = " @brief Staging options."]
	pub options: ukv_options_t,
	#[doc = " @brief Optional output for the transaction stage sequence number."]
	pub sequence_number: *mut ukv_sequence_number_t,
}
#[test]
fn bindgen_test_layout_ukv_transaction_stage_t() {
	const UNINIT: ::std::mem::MaybeUninit<ukv_transaction_stage_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ukv_transaction_stage_t>(),
		40usize,
		concat!("Size of: ", stringify!(ukv_transaction_stage_t))
	);
	assert_eq!(
		::std::mem::align_of::<ukv_transaction_stage_t>(),
		8usize,
		concat!("Alignment of ", stringify!(ukv_transaction_stage_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(ukv_transaction_stage_t), "::", stringify!(db))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(ukv_transaction_stage_t), "::", stringify!(error))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).transaction) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(ukv_transaction_stage_t),
			"::",
			stringify!(transaction)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(ukv_transaction_stage_t),
			"::",
			stringify!(options)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(ukv_transaction_stage_t),
			"::",
			stringify!(sequence_number)
		)
	);
}
extern "C" {
	#[doc = " @brief Stages an ACID transaction for Two Phase Commits.\n @see `ukv_transaction_stage_t`."]
	pub fn ukv_transaction_stage(arg1: *mut ukv_transaction_stage_t);
}
#[doc = " @brief Commits an ACID transaction.\n @see `ukv_transaction_commit()`.\n\n Regardless of result, the content is preserved to allow further\n logging, serialization or retries. The underlying memory can be\n cleaned and reused by consecutive `ukv_transaction_init()` call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ukv_transaction_commit_t {
	#[doc = " @brief Already open database instance."]
	pub db: ukv_database_t,
	#[doc = " @brief Pointer to exported error message."]
	pub error: *mut ukv_error_t,
	#[doc = " @brief Initialized transaction handle."]
	pub transaction: ukv_transaction_t,
	#[doc = " @brief Staging options."]
	pub options: ukv_options_t,
	#[doc = " @brief Optional output for the transaction commit sequence number."]
	pub sequence_number: *mut ukv_sequence_number_t,
}
#[test]
fn bindgen_test_layout_ukv_transaction_commit_t() {
	const UNINIT: ::std::mem::MaybeUninit<ukv_transaction_commit_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<ukv_transaction_commit_t>(),
		40usize,
		concat!("Size of: ", stringify!(ukv_transaction_commit_t))
	);
	assert_eq!(
		::std::mem::align_of::<ukv_transaction_commit_t>(),
		8usize,
		concat!("Alignment of ", stringify!(ukv_transaction_commit_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(ukv_transaction_commit_t), "::", stringify!(db))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(ukv_transaction_commit_t), "::", stringify!(error))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).transaction) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(ukv_transaction_commit_t),
			"::",
			stringify!(transaction)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(ukv_transaction_commit_t),
			"::",
			stringify!(options)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(ukv_transaction_commit_t),
			"::",
			stringify!(sequence_number)
		)
	);
}
extern "C" {
	#[doc = " @brief Commits an ACID transaction.\n @see `ukv_transaction_commit_t`."]
	pub fn ukv_transaction_commit(arg1: *mut ukv_transaction_commit_t);
}
extern "C" {
	#[doc = " @brief Deallocates reusable memory arenas.\n Passing NULLs is safe."]
	pub fn ukv_arena_free(arg1: ukv_arena_t);
}
extern "C" {
	#[doc = " @brief Resets the transaction and deallocates the underlying memory.\n Passing NULLs is safe."]
	pub fn ukv_transaction_free(arg1: ukv_transaction_t);
}
extern "C" {
	#[doc = " @brief Closes the DB and deallocates used memory.\n The database would still persist on disk.\n Passing NULLs is safe."]
	pub fn ukv_database_free(arg1: ukv_database_t);
}
extern "C" {
	#[doc = " @brief Deallocates error messages.\n Passing NULLs is safe."]
	pub fn ukv_error_free(arg1: ukv_error_t);
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
